<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wet Weather BMP Suitability</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding:0; }
    #controls { padding: 1em; background:#f8f8f8; }
    #map { height: 400px; }
    table { width:100%; border-collapse:collapse; margin-top:1em; }
    th, td { border:1px solid #ccc; padding:6px; vertical-align: top; }
    th { background:#e0f7fa; }
    .inner-table { width:100%; border-collapse:collapse; margin:4px 0; }
    .inner-table th, .inner-table td { border:1px solid #ddd; padding:4px; font-size:0.9em; }
    .driver-checkboxes {
      /* increase max-height for more visible items */
      max-height: 300px;
      overflow-y: auto;
      padding-right: 2px;
      font-size: 0.8em;
      line-height: 1.2em;
      /* take full cell width */
      width: 100%;
    }
    .driver-group { margin-bottom:8px; }
    .driver-group h4 { margin:4px 0; font-size:0.9em; }
    .driver-group label { display:block; margin-left:8px; }
    #status { margin-top:.5em; height:1em; color: green; }
  </style>
</head>
<body>
  <div id="controls">
    <h2>1. Load Planning Districts GeoJSON</h2>
    <input type="file" id="geojsonInput" accept=".geojson"/>
    <h2>2. Load Scoring Rubric CSV</h2>
    <input type="file" id="csvInput" accept=".csv"/>
    <button id="processBtn">Run Suitability Calculator</button>
    <div id="status"></div>
  </div>

  <div id="map"></div>

  <table id="resultsTable">
    <thead>
      <tr>
        <th>Name</th>
        <th>Strategy Scores</th>
        <th style="width:220px;">Drivers</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
  let geoData=null, rubric=null, results=[], driversList=[];
  let selectedDrivers={};

  function parseCSV(text) {
    const [hdr,...lines] = text.trim().split(/\r?\n/);
    const cols = hdr.split(',').map(c=>c.trim());
    return lines.map(l=>{
      const vals=l.split(',').map(v=>v.trim());
      return cols.reduce((o,c,i)=>(o[c]=vals[i],o),{});
    });
  }
  function parseScore(s){return {'++':2,'+':1,'=':0,'-':-1,'--':-2}[s]||0;}
  function evalThreshold(v,thr){
    if(thr.includes('and <')){const [min,max]=thr.replace('>=','').split('and <').map(Number);return v>=min&&v<max;}
    if(thr.startsWith('>=')) return v>=+thr.slice(2);
    if(thr.startsWith('<'))  return v< +thr.slice(1);
    return false;
  }

  document.getElementById('geojsonInput').onchange = e=>{
    const f=e.target.files[0]; if(!f) return;
    const r=new FileReader(); r.onload=ev=>{geoData=JSON.parse(ev.target.result); updateStatus('GeoJSON loaded');};
    r.readAsText(f);
  };
  document.getElementById('csvInput').onchange = e=>{
    const f=e.target.files[0]; if(!f) return;
    const r=new FileReader(); r.onload=ev=>{
      rubric=parseCSV(ev.target.result);
      driversList=[...new Set(rubric.filter(r=>r.Type==='Driver').map(r=>r.Driver))];
      updateStatus('Rubric loaded');
    };
    r.readAsText(f);
  };
  document.getElementById('processBtn').onclick = ()=>{
    if(!geoData||!rubric) return updateStatus('Load files first',true);
    computeSuitability(); renderTable(); renderMap(); updateStatus('Complete');
  };

  const metrics=[
    {key:'Slope',label:'Slope'},
    {key:'POPDENS_CY',label:'Population Density'},
    {key:'Impervious',label:'Percent Impervious'},
    {key:'BuildingHeight',label:'Average Building Height'},
    {key:'Bedrock',label:'Bedrock Depth'},
    {key:'Groundwater',label:'Groundwater'}
  ];

function computeSuitability() {
  results = geoData.features.map(f => {
    const p    = f.properties;
    const name = p.DIST_NAME;

    // 1) Build up condition scores, driver scores, and total scores
    const condScores  = {};
    const drvScores   = {};
    const totalScores = {};

    // a) Condition logic
    metrics.forEach(m => {
      const v = +p[m.key] || 0;
      rubric
        .filter(r =>
          r.Type === 'Condition' &&
          r.Subcategory === m.label &&
          evalThreshold(v, r.Threshold)
        )
        .forEach(r => {
          const sc = parseScore(r.Score);
          condScores  [r.Strategy] = (condScores  [r.Strategy] || 0) + sc;
          totalScores [r.Strategy] = (totalScores [r.Strategy] || 0) + sc;
        });
    });

    // b) Driver logic
    (selectedDrivers[name] || []).forEach(drv => {
      rubric
        .filter(r =>
          r.Type === 'Driver' &&
          r.Driver === drv
        )
        .forEach(r => {
          const sc = parseScore(r.Score);
          drvScores    [r.Strategy] = (drvScores    [r.Strategy] || 0) + sc;
          totalScores  [r.Strategy] = (totalScores  [r.Strategy] || 0) + sc;
        });
    });

    // 2) Original v1 console.log audit trail
    console.group(`🗺 ${name}`);
    metrics.forEach(m => {
      const val     = +p[m.key] || 0;
      const matches = rubric.filter(r =>
        r.Subcategory === m.label &&
        evalThreshold(val, r.Threshold)
      );
      if (matches.length) {
        console.group(`🔹 ${m.label} = ${val.toFixed(2)}`);
        matches.forEach(r => {
          const sc = parseScore(r.Score);
          console.log(`✓ ${r.Threshold} → ${r.Strategy} (${sc >= 0 ? '+'+sc : sc})`);
        });
        console.groupEnd();
      } else {
        console.log(`— ${m.label} = ${val.toFixed(2)}: no thresholds matched`);
      }
    });
    console.log('🏁 Totals by Strategy:');
    console.table(totalScores);
    const maxScore   = Math.max(...Object.values(totalScores), 0);
    const bestStrats = Object.entries(totalScores)
      .filter(([, s]) => s === maxScore)
      .map(([s]) => s);
    console.log(`🏆 Best: ${bestStrats.join(', ')} (Score: ${maxScore})`);
    console.groupEnd();

    // 3) Return the result object
    return {
      name,
      score:    maxScore,
      strategy: bestStrats,
      scores:   totalScores
    };
  });
}


  function renderTable(){
    const tbody=document.querySelector('#resultsTable tbody'); tbody.innerHTML='';
    results.forEach(r=>{
      const tr=document.createElement('tr');
      // strategy scores
      const innerRows=Object.entries(r.scores).map(([s,v])=>`<tr><td>${s}</td><td>${v}</td></tr>`).join('');
      tr.innerHTML=`
        <td>${r.name}</td>
        <td>
          <table class="inner-table">
            <thead><tr><th>Strategy</th><th>Score</th></tr></thead>
            <tbody>${innerRows}</tbody>
          </table>
        </td>
        <td><div class="driver-checkboxes" data-district="${r.name}"></div></td>
      `;
      tbody.appendChild(tr);
      // group drivers
      const groups={};
      driversList.forEach(d=>{
        const [grp, ...rest] = d.split(' - ');
        if(!groups[grp]) groups[grp]=[];
        groups[grp].push(d);
      });
      const box=tr.querySelector('.driver-checkboxes');
      Object.entries(groups).forEach(([grp, items])=>{
        const div=document.createElement('div'); div.className='driver-group';
        div.innerHTML=`<h4>${grp}</h4>`;
        items.forEach(d=>{
          const ck=(selectedDrivers[r.name]||[]).includes(d)?'checked':'';
          const lbl=document.createElement('label');
          lbl.innerHTML=`<input type="checkbox" data-district="${r.name}" data-driver="${d}" ${ck}> ${d.split(' - ').slice(1).join(' - ')}`;
          div.appendChild(lbl);
        });
        box.appendChild(div);
      });
    });
    document.querySelectorAll('.driver-checkboxes input').forEach(cb=>{
      cb.onchange=e=>{
        const n=e.target.dataset.district;
        selectedDrivers[n]=Array.from(
          document.querySelectorAll(`.driver-checkboxes[data-district="${n}"] input:checked`)
        ).map(el=>el.dataset.driver);
        computeSuitability(); renderTable(); renderMap();
      };
    });
  }

  let map,layer;
  function renderMap(){
    if(!map){map=L.map('map').setView([39.95,-75.17],12);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    }
    if(layer) map.removeLayer(layer);
    layer=L.geoJSON(geoData,{style:f=>{
      const r=results.find(x=>x.name===f.properties.DIST_NAME)||{};
      const s=r.score;
      return{color:'#555',fillColor:s>1?'#006400':s>0?'#228B22':s===0?'#999999':s>-2?'#FFA07A':'#FF0000',weight:1,fillOpacity:0.6};
    },onEachFeature:(f,ly)=>{const r=results.find(x=>x.name===f.properties.DIST_NAME)||{};
      ly.bindPopup(
  `<b>${r.name}</b><br>`+
  `Score: ${r.score}<br>`+
  `<em>Best Strateg${r.strategy.length>1?'ies':'y'}:</em> ${r.strategy.join(', ')}`
);

    }}).addTo(map);
  }

  function updateStatus(msg,err=false){const d=document.getElementById('status');d.textContent=msg;d.style.color=err?'red':'green';}
  </script>
</body>
</html>
